// SharoUI Textarea Component
// Multi-line text input with full keyboard support

import "std/sharoui/theme.sharo"
import "std/sharoui/utils.sharo"

// SDL3 event types
TEXT_INPUT_EVENT := 771
KEY_DOWN_EVENT := 768

// SDL3 scancodes
KEY_BACKSPACE := 42
KEY_DELETE := 76
KEY_RETURN := 40
KEY_LEFT := 80
KEY_RIGHT := 79
KEY_HOME := 74
KEY_END := 77
KEY_UP := 82
KEY_DOWN := 81

// Textarea state
type TextareaState {
    text: str,
    cursorPos: int,
    scrollOffset: int,
    focused: bool,
    targetCol: int  // Remembered column for vertical movement
}

newTextareaState() TextareaState {
    return TextareaState("", 0, 0, false, 0)
}

newTextareaStateWith(initialText str) TextareaState {
    return TextareaState(initialText, len(initialText), 0, false, len(initialText))
}

// Draw a textarea - returns updated state
drawTextarea(renderer ptr, font ptr, state TextareaState,
             x int, y int, w int, h int,
             placeholder str, mx int, my int, clicked bool) TextareaState {

    hovered := isInRect(mx, my, x, y, w, h)
    focused := state.focused

    if clicked {
        focused = hovered
    }

    // Border color based on state
    borderColor := BORDER
    if hovered { borderColor = TEXT_MUTED }
    if focused { borderColor = ACCENT }

    // Draw border and background
    drawFilledRect(renderer, x, y, w, h, borderColor, 255)
    drawFilledRect(renderer, x + 1, y + 1, w - 2, h - 2, BG_SECONDARY, 255)

    text := state.text
    cursorPos := state.cursorPos
    padding := SPACING_SM

    // Draw text or placeholder
    textX := x + padding
    textY := y + padding
    lineHeight := 18

    if len(text) == 0 {
        drawColoredText(renderer, font, placeholder, textX, textY, TEXT_MUTED)
    } else {
        // Split by newlines and draw each line
        lines := split(text, "\n")
        lineCount := len(lines)
        i := 0
        for i < lineCount {
            line := lines[i]
            drawColoredText(renderer, font, line, textX, textY + i * lineHeight, TEXT_PRIMARY)
            i += 1
        }
    }

    // Draw cursor when focused
    if focused {
        // Find which line the cursor is on and position within that line
        beforeCursor := substr(text, 0, cursorPos)
        cursorLine := 0
        lastNewline := -1

        // Count newlines before cursor to find line number
        j := 0
        for j < len(beforeCursor) {
            ch := substr(beforeCursor, j, 1)
            if ch == "\n" {
                cursorLine += 1
                lastNewline = j
            }
            j += 1
        }

        // Get text on current line before cursor
        lineStart := lastNewline + 1
        textOnLine := substr(beforeCursor, lineStart, len(beforeCursor) - lineStart)

        cursorDrawX := textX + getTextWidth(font, textOnLine)
        cursorDrawY := textY + cursorLine * lineHeight
        drawFilledRect(renderer, cursorDrawX, cursorDrawY, 2, 16, ACCENT, 255)
    }

    return TextareaState(text, cursorPos, state.scrollOffset, focused, state.targetCol)
}

// Handle text input event - call when event type is TEXT_INPUT_EVENT (771)
textareaHandleTextInput(state TextareaState, inputText str) TextareaState {
    if !state.focused { return state }
    if len(inputText) == 0 { return state }

    // Insert text at cursor position
    before := substr(state.text, 0, state.cursorPos)
    after := substr(state.text, state.cursorPos, len(state.text) - state.cursorPos)
    newText := before + inputText + after
    newCursor := state.cursorPos + len(inputText)

    // Reset targetCol to current column after typing
    newCol := getColumnAtPos(newText, newCursor)
    return TextareaState(newText, newCursor, state.scrollOffset, true, newCol)
}

// Helper: get column position within current line
getColumnAtPos(text str, pos int) int {
    // Find last newline before pos
    lastNewline := -1
    i := 0
    for i < pos {
        ch := substr(text, i, 1)
        if ch == "\n" {
            lastNewline = i
        }
        i += 1
    }
    return pos - lastNewline - 1
}

// Handle key down event - call when event type is KEY_DOWN_EVENT (768)
textareaHandleKeyDown(state TextareaState, scancode int) TextareaState {
    if !state.focused { return state }

    text := state.text
    cursorPos := state.cursorPos
    textLen := len(text)

    // Backspace - delete character before cursor
    if scancode == KEY_BACKSPACE {
        if cursorPos > 0 {
            before := substr(text, 0, cursorPos - 1)
            after := substr(text, cursorPos, textLen - cursorPos)
            newText := before + after
            newPos := cursorPos - 1
            newCol := getColumnAtPos(newText, newPos)
            return TextareaState(newText, newPos, state.scrollOffset, true, newCol)
        }
        return state
    }

    // Delete - delete character after cursor
    if scancode == KEY_DELETE {
        if cursorPos < textLen {
            before := substr(text, 0, cursorPos)
            after := substr(text, cursorPos + 1, textLen - cursorPos - 1)
            newText := before + after
            newCol := getColumnAtPos(newText, cursorPos)
            return TextareaState(newText, cursorPos, state.scrollOffset, true, newCol)
        }
        return state
    }

    // Enter - insert newline
    if scancode == KEY_RETURN {
        before := substr(text, 0, cursorPos)
        after := substr(text, cursorPos, textLen - cursorPos)
        newText := before + "\n" + after
        newPos := cursorPos + 1
        return TextareaState(newText, newPos, state.scrollOffset, true, 0)  // Column 0 after newline
    }

    // Left arrow - move cursor left
    if scancode == KEY_LEFT {
        if cursorPos > 0 {
            newPos := cursorPos - 1
            newCol := getColumnAtPos(text, newPos)
            return TextareaState(text, newPos, state.scrollOffset, true, newCol)
        }
        return state
    }

    // Right arrow - move cursor right
    if scancode == KEY_RIGHT {
        if cursorPos < textLen {
            newPos := cursorPos + 1
            newCol := getColumnAtPos(text, newPos)
            return TextareaState(text, newPos, state.scrollOffset, true, newCol)
        }
        return state
    }

    // Home - move cursor to start
    if scancode == KEY_HOME {
        return TextareaState(text, 0, state.scrollOffset, true, 0)
    }

    // End - move cursor to end
    if scancode == KEY_END {
        newCol := getColumnAtPos(text, textLen)
        return TextareaState(text, textLen, state.scrollOffset, true, newCol)
    }

    // Up arrow - move cursor to previous line
    if scancode == KEY_UP {
        // Find current line info
        lines := split(text, "\n")
        lineCount := len(lines)

        // Find which line cursor is on
        currentLine := 0
        charCount := 0

        i := 0
        for i < lineCount {
            lineLen := len(lines[i])
            lineEnd := charCount + lineLen
            if i < lineCount - 1 {
                lineEnd += 1  // Account for newline
            }

            if cursorPos <= lineEnd {
                currentLine = i
                i = lineCount  // Break
            } else {
                charCount = lineEnd
                i += 1
            }
        }

        // Can't go up from first line
        if currentLine == 0 {
            return state
        }

        // Use remembered targetCol for vertical movement
        prevLine := currentLine - 1
        prevLineLen := len(lines[prevLine])
        col := state.targetCol
        if col > prevLineLen {
            col = prevLineLen
        }

        // Calculate absolute position
        newPos := 0
        j := 0
        for j < prevLine {
            newPos += len(lines[j]) + 1  // +1 for newline
            j += 1
        }
        newPos += col

        // Keep targetCol unchanged for vertical movement
        return TextareaState(text, newPos, state.scrollOffset, true, state.targetCol)
    }

    // Down arrow - move cursor to next line
    if scancode == KEY_DOWN {
        // Find current line info
        lines := split(text, "\n")
        lineCount := len(lines)

        // Find which line cursor is on
        currentLine := 0
        charCount := 0

        i := 0
        for i < lineCount {
            lineLen := len(lines[i])
            lineEnd := charCount + lineLen
            if i < lineCount - 1 {
                lineEnd += 1  // Account for newline
            }

            if cursorPos <= lineEnd {
                currentLine = i
                i = lineCount  // Break
            } else {
                charCount = lineEnd
                i += 1
            }
        }

        // Can't go down from last line
        if currentLine >= lineCount - 1 {
            return state
        }

        // Use remembered targetCol for vertical movement
        nextLine := currentLine + 1
        nextLineLen := len(lines[nextLine])
        col := state.targetCol
        if col > nextLineLen {
            col = nextLineLen
        }

        // Calculate absolute position
        newPos := 0
        j := 0
        for j < nextLine {
            newPos += len(lines[j]) + 1  // +1 for newline
            j += 1
        }
        newPos += col

        // Keep targetCol unchanged for vertical movement
        return TextareaState(text, newPos, state.scrollOffset, true, state.targetCol)
    }

    // Unknown key - preserve state including targetCol
    return state
}
